@startuml ClientServer_MultiplayerStart
title Multiplayer Game Creation & Start (Client-Server via Events)

actor Player2
actor Player1
participant UI
participant ClientApp
participant GameEventsManager as GEM
participant ServerApp
participant GameHandler
participant GameSession
participant GameRunner

== Player 1 Creates Game ==
'Client requests creation of a GameSession'
Player1 --> UI ++ : Clicks "Start single player game"
note right: Client initiates creation of a GameSession
UI -> ClientApp ++ : handleCreateGame("Board1.txt")
ClientApp --> GEM : publish(CreateGameSessionRequest("Board1.txt"))
ClientApp -> UI --
UI -> Player1 -- : CreateGameSessionRequest sent


'Server receives a request to create a GameSession'
GEM --> ServerApp ++ : callback(CreateGameSessionRequest)
note right: Server receives a request to create a GameSession
ServerApp -> GameHandler ++ : loadGame("Board1.txt")
' GameHandler creates Level internally '
create GameSession
GameHandler -> GameSession ++ : new GameSession(id, level, GEM)
note right: Session subscribes to GameSessionEvents etc.
create GameRunner
GameSession -> GameRunner ++ : new GameRunner(id, level, GEM)
GameRunner -> GameRunner : m_gameStatus = CREATING
GameRunner -> GameSession --
note right: GameRunner in state WAITING
GameSession -> GameHandler --
note right: GameSession in state WAITING. \n Waits for all the required players to join
GameHandler -> ServerApp -- : returns std::unique_ptr<GameSession> // ServerApp stores sessions
note left: Server created a GameSession, now returning SessionInfo
ServerApp --> GEM : publish(CreateGameSessionResponse(sessionId, sessionInfo))
note left: SessionInfo contains information about the hostId

'Client immediately joins the game they requested to create'
alt Player1 initiated a game
    'Client receives a response for GameSession creation'
    GEM --> ClientApp : callback(CreateGameSessionResponse)
    note left: Client receives a response for GameSession creation
    ClientApp -> ClientApp : storeNewSession(sessionId, SessionInfo)
else Players want to find some games
    == Players search for GameSessions ==
    note over Player1, ServerApp : Players search for GameSessions 'id'
    Player2 -> UI ++ : Clicks in multiplayer lobby "Search games"
    UI -> ClientApp ++ : handleSearchGame()
    ClientApp --> GEM  : publish(FindGameSessionsRequest())
    ClientApp -> UI --
    UI -> Player2 -- : Searched for games

    GEM --> ServerApp : callback(FindGameSessionsRequest)
    ServerApp -> ServerApp : handleFindGameSessionsRequest()
    ServeApp --> GEM : publish(FindGameSessionsResponse([{sessionId, SessionInfo}, {...}]))
    GEM --> ClientApp : callback(FindGameSessionsResponse)
    ClientApp -> ClientApp : storeNewSession([{sessionId, SessionInfo}, {...}])
end


note over ClientApp : Players join the game
alt Did player start the game?
    ClientApp -> ClientApp ++ : handleJoinTheGame(sessionId)
else Players want to join a game
    Player2 -> UI ++ : Clicks "Join Game(sessionId)"
    UI -> ClientApp : handleJoinGame(sessionId)
end
ClientApp --> GEM ++ : publish(JoinGameRequest(sessionId))


GEM -> ServerApp ++ : callback(RequestJoinGameEvent)
ServerApp -> GameSession : getSession(id)
alt Session exists and accepts players
    ServerApp -> ServerApp : Add Player 2 logic...
    ServerApp -> GEM ++ : publish(SessionUpdateEvent(id, info(p1,p2 joined, WAITING)))
    note right: Informs all clients Player 2 joined
else Session invalid/full
    ServerApp -> GEM ++ : publish(JoinRejectedEvent(id, reason))
    ServerApp --> GEM --
deactivate ServerApp
    GEM -> ClientApp ++ : callback(JoinRejectedEvent)
    ClientApp -> UI : showError("Cannot join")
    deactivate ClientApp
end

GEM -> ClientApp ++ : callback(SessionUpdateEvent) ' Both P1 & P2 clients receive '
ClientApp -> ClientApp : updateLocalState(info)
ClientApp -> UI : updatePlayerList(), showStatus("Waiting...")
deactivate ClientApp

== Players Ready Up ==
Player1 -> UI : Clicks "Ready"
UI -> ClientApp ++ : handleReadyClick()
ClientApp -> GEM ++ : publish(PlayerReadyEvent(id, p1_id))
deactivate ClientApp

GEM -> GameSession ++ : callback(PlayerReadyEvent)
GameSession -> GameSession : markPlayerReady(p1_id), checkAllReady()
alt Not all ready
    GameSession -> GameSession : continue waiting
end
deactivate GameSession

Player2 -> UI : Clicks "Ready"
UI -> ClientApp ++ : handleReadyClick()
ClientApp -> GEM ++ : publish(PlayerReadyEvent(id, p2_id))
deactivate ClientApp

GEM -> GameSession ++ : callback(PlayerReadyEvent)
GameSession -> GameSession : markPlayerReady(p2_id), checkAllReady()
alt All players ready
    GameSession -> GEM ++ : publish(SessionUpdateEvent(id, info(status=RUNNING)))
    GameSession -> GameRunner ++ : startGame()
    note right of GameRunner : Sets status RUNNING,\nstarts gameLoop thread
    deactivate GameRunner
else Not all ready
    GameSession -> GameSession : continue waiting
end
deactivate GameSession

GEM -> ClientApp ++ : callback(SessionUpdateEvent) ' Both P1 & P2 clients receive '
ClientApp -> ClientApp : updateLocalState(status=RUNNING)
ClientApp -> UI : updateStatus("Running!")
deactivate ClientApp

@enduml